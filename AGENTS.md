# AIコーディングエージェント向けコード修正と貢献のガイドライン

この指示書は、AIによるコードの貢献が、**正確性**、**保守性**、そして**プロジェクトのアーキテクチャとの整合性**を確実に満たすように導くものです。明示的に別段の指示がない限り、各ルールを厳密に順守してください。

## 1. 変更範囲の最小化

- 要件を満たすための**最小単位**（関数、クラス、モジュールなど）を特定してください。
- **無関係なコード**は修正しないでください。
- 正確性のために必要であるか、または**明示的に要求されない限り**、リファクタリングは避けてください。

## 2. システムの振る舞いの維持

- 既存の機能に影響を与えたり、意図した範囲外の出力を変更したりしないことを確実にしてください。
- 特に指示がない限り、元のパターン、API、および**アーキテクチャ構造**を維持してください。

## 3. 段階的な変更戦略

- **原則:** 最小限に絞り込んだ変更を実施してください。
- **必要に応じて:** 小規模で局所的なリファクタリング（例：変数名の変更、関数の抽出など）を適用します。
- **明示的に要求された場合のみ:** ファイルやモジュールをまたいだ広範な再構築を実行してください。

## 4. 曖昧な点については行動前に明確化

- タスクの範囲が不明確な場合や、複数のコンポーネントに影響を及ぼす可能性がある場合は、作業を中断し、**明確化を要求**してください。
- 説明されている要件を超えて、**より広範な意図を推測**してはなりません。

## 5. 範囲外の改善点は実装せず、記録に留める

- 関連する改善点を見つけても、**変更は行わず**、コメントなどで記録しておいてください。
- 例: `// Note: Function Y may benefit from similar validation. (注：関数Yにも同様の検証を適用すると有益かもしれません。)`

## 6. 変更の**可逆性**を確保

- 変更は、**容易に取り消せる**ように記述してください。
- **連鎖的**な変更や、密接に結合した（**密結合な**）修正は避けてください。

## 7. コードの品質基準

- **明瞭性:** 説明的な名前を使用してください。関数は短く、単一の目的を持つように保ってください。
- **一貫性:** 既存のスタイル、パターン、および命名規則に一致させてください。
- **エラー処理:** try/catch（JS/TS）を使用してください。失敗の可能性（例：I/O、ユーザー入力）を予測してください。
- **セキュリティ:** 入力をサニタイズ（無害化）してください。機密情報を**ハードコーディングすることは避け**、設定には環境変数を使用してください。
- **テスト容易性:** ユニットテストが可能な設計にしてください。グローバルな状態よりも**依存性注入**（Dependency Injection）を優先してください。

## 8. テストの要件

- 変更に**直接関連するテスト**のみを追加または修正してください。
- **成功パスと失敗パスの両方**がカバーされていることを確認してください。
- **明示的に許可されない限り**、既存のテストを削除しないでください。
- テストフレームワークがインストールされていない場合は、**テストを追加しないでください**。

## 9. コミットメッセージの形式

- [Conventional Commits](https://www.conventionalcommits.org)の形式を使用してください。
- 構造: type(scope): messageとし、**命令形**で記述してください。
- 例:
  - feat(auth): add login validation for expired tokens
  - fix(api): correct status code on error
  - test(utils): add tests for parseDate helper

## 10. **明示的に要求されない限り**禁止される行為

- ファイルをまたいだ**広域なリファクタリング**
- **無関係なモジュール**への変更
- 機能的な理由のない、**整形やスタイルのみ**の要素の修正
- **新しい依存関係**の追加

## 11. 曖昧な参照への対処

- 「このコンポーネント」や「ヘルパー」といった**曖昧な用語**に遭遇した場合は、可能な限り**正確なファイルパスと行番号**を参照するようにしてください。
- 正確な場所が不明確な場合は、**続行する前に明確化を求めてください**。
- 曖昧な参照の意味を**決して推測しないでください**。

---

常に記述されたスコープとプロンプトの制約内で行動してください。**確信が持てない場合は、まず質問してください。**


# Svelte MCPエージェントガイドライン

あなたはSvelte MCPサーバーを使用することができ、包括的なSvelte 5とSvelteKitのドキュメントにアクセスできます。利用可能なツールの効果的な使い方は以下の通りです:

## 利用可能なMCPツール:

### 1. list-sections

利用可能なすべてのドキュメントセクションを発見するために、最初にこれを使用してください。タイトル、use_cases、パスを含む構造化されたリストを返します。
SvelteまたはSvelteKitのトピックについて質問された場合、常にチャットの開始時にこのツールを使用して関連するセクションを見つけてください。

### 2. get-documentation

特定のセクションの完全なドキュメントコンテンツを取得します。単一または複数のセクションを受け付けます。
list-sectionsツールを呼び出した後、返されたドキュメントセクション(特にuse_casesフィールド)を分析し、次にget-documentationツールを使用してユーザーのタスクに関連するすべてのドキュメントセクションを取得する必要があります。

### 3. svelte-autofixer

Svelteコードを分析し、問題と提案を返します。
Svelteコードを書く際は、ユーザーに送信する前に必ずこのツールを使用してください。問題や提案が返されなくなるまで繰り返し呼び出してください。

### 4. playground-link

提供されたコードでSvelte Playgroundリンクを生成します。
コードの完成後、ユーザーにplaygroundリンクが必要かどうか尋ねてください。ユーザーの確認後にのみこのツールを呼び出し、プロジェクト内のファイルにコードが書き込まれた場合は絶対に呼び出さないでください。
